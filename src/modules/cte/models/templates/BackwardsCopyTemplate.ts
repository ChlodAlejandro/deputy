import BackwardsCopyTemplateRow, {
	backwardsCopyTemplateRowParameters,
	RawBackwardsCopyTemplateRow
} from './BackwardsCopyTemplateRow';
import { AttributionNoticePageLayout } from '../../ui/pages/AttributionNoticePageLayout';
import BackwardsCopyTemplatePage from '../../ui/pages/BackwardsCopyTemplatePage';
import { AttributionNoticePageGenerator } from '../../ui/AttributionNoticePageGenerator';
import RowedAttributionNotice from '../RowedAttributionNotice';

/**
 * Represents a single {{copied}} template in the Parsoid document.
 */
export default class BackwardsCopyTemplate
	extends RowedAttributionNotice<BackwardsCopyTemplateRow>
	implements AttributionNoticePageGenerator {

	// TEMPLATE OPTIONS

	/**
	 * The version number of a particular version that predates publication of the
	 * referenced work. The text generated by the template will link to the specified
	 * version.
	 */
	id?: string;
	/**
	 * Removes the tracking category. This shouldn't be editable within CTE, but
	 * should still be carried over as a parameter.
	 */
	demo?: string;
	/**
	 * Comments shown at the bottom of the notice.
	 */
	comments?: string;

	/**
	 * @return This template's rows.
	 */
	get rows(): BackwardsCopyTemplateRow[] {
		return this._rows;
	}

	/**
	 * Parses parameters into class properties. This WILL destroy unknown
	 * parameters and parameters in the incorrect order!
	 *
	 * This function does not modify the template data.
	 */
	parse() {
		if ( this.node.getParameter( 'demo' ) ) {
			this.demo = this.node.getParameter( 'demo' );
		}

		// Extract {{backwards copy}} rows.
		const rows = [];

		// Numberless
		if ( this.hasRowParameters( backwardsCopyTemplateRowParameters ) ) {
			// If `from`, `to`, ..., or `merge` is found.
			rows.push( new BackwardsCopyTemplateRow(
				this.extractRowParameters<RawBackwardsCopyTemplateRow>(
					backwardsCopyTemplateRowParameters
				),
				this
			) );
		}

		// Numbered
		let i = 1, continueExtracting = true;
		do {
			if ( this.hasRowParameters( backwardsCopyTemplateRowParameters, i ) ) {
				rows.push( new BackwardsCopyTemplateRow(
					this.extractRowParameters<RawBackwardsCopyTemplateRow>(
						backwardsCopyTemplateRowParameters, i
					),
					this
				) );
			} else if ( !( i === 1 && rows.length > 0 ) ) {
				// Row doesn't exist. Stop parsing from here.
				continueExtracting = false;
			}

			i++;
		} while ( continueExtracting );
		/**
		 * All the rows of this template.
		 *
		 * @type {BackwardsCopyTemplateRow[]}
		 */
		this._rows = rows;
	}

	/**
	 * Saves the current template data to the Parsoid element.
	 */
	save() {
		if ( this.demo ) {
			this.node.setParameter( 'demo', this.demo );
		}

		const existingParameters = this.node.getParameters();
		for ( const param in existingParameters ) {
			if ( backwardsCopyTemplateRowParameters.some( ( v ) => param.startsWith( v ) ) ) {
				// This is a row parameter. Remove it in preparation for rebuild (further below).
				this.node.removeParameter( param );
			}
		}

		if ( this._rows.length === 1 ) {
			// If there is only one row, don't bother with numbered rows.
			for ( const param of backwardsCopyTemplateRowParameters ) {
				if ( this._rows[ 0 ][ param ] !== undefined ) {
					this.node.setParameter( param, this._rows[ 0 ][ param ] );
				}
			}

		} else {
			// If there are multiple rows, add number suffixes (except for i = 0).
			for ( let i = 0; i < this._rows.length; i++ ) {
				for ( const param of backwardsCopyTemplateRowParameters ) {
					if ( this._rows[ i ][ param ] !== undefined ) {
						this.node.setParameter(
							param + ( i === 0 ? '' : i + 1 ),
							this._rows[ i ][ param ]
						);
					}
				}
			}
		}

		this.dispatchEvent( new Event( 'save' ) );
	}

	/**
	 * Destroys this template completely.
	 */
	destroy() {
		this.node.destroy();
		// Self-destruct
		Object.keys( this ).forEach( ( k ) => delete ( this as any )[ k ] );
		this.dispatchEvent( new Event( 'destroy' ) );
	}

	/**
	 * @inheritDoc
	 */
	generatePage( dialog: any ): AttributionNoticePageLayout {
		return BackwardsCopyTemplatePage( {
			backwardsCopyTemplate: this,
			parent: dialog
		} );
	}

	/**
	 * Copies in the rows of another {@link BackwardsCopyTemplate}, and
	 * optionally deletes that template or clears its contents.
	 *
	 * @param template The template to copy from.
	 * @param options Options for this merge.
	 * @param options.delete
	 *        Whether the reference template will be deleted after merging.
	 * @param options.clear
	 *        Whether the reference template's rows will be cleared after merging.
	 */
	merge( template: BackwardsCopyTemplate, options: { delete?: boolean, clear?: boolean } = {} ) {
		if ( template.rows === undefined || template === this ) {
			// Deleted or self
			return;
		}
		for ( const row of template.rows ) {
			if ( options.clear ) {
				row.parent = this;
			} else {
				this.addRow( row.clone( this ) );
			}
		}
		if ( options.delete ) {
			template.destroy();
		}
	}

}
